#!/usr/bin/env node

/**
 * Verify Database Setup
 * 
 * This script verifies that all database components are properly set up:
 * - notification_email table structure
 * - Indexes
 * - Triggers
 * - RLS policies
 * - Cron functions
 */

// Load environment variables from .env.local
require('dotenv').config({ path: '.env.local' });

const { supabaseAdmin } = require('../lib/supabase/admin');

function log(message, type = 'info') {
  const timestamp = new Date().toISOString();
  const prefix = type === 'error' ? '‚ùå' : type === 'success' ? '‚úÖ' : '‚ÑπÔ∏è';
  console.log(`${prefix} [${timestamp}] ${message}`);
}

async function verifyTableStructure() {
  log('üîç Verifying notification_email table structure...');
  
  try {
    // Check if table exists and get its structure
    const { data: columns, error } = await supabaseAdmin
      .rpc('get_table_columns', { table_name: 'notification_email' })
      .catch(() => {
        // Fallback: try to query the table directly
        return supabaseAdmin
          .from('notification_email')
          .select('*')
          .limit(1);
      });

    if (error) {
      log(`‚ùå Table verification failed: ${error.message}`, 'error');
      return false;
    }

    log('‚úÖ notification_email table exists', 'success');
    
    // Check specific columns
    const requiredColumns = [
      'id', 'order_id', 'event_type', 'to_email', 'subject', 
      'html', 'text', 'status', 'attempts', 'error', 
      'locked_at', 'created_at', 'updated_at'
    ];

    log('üìã Checking required columns...');
    for (const column of requiredColumns) {
      try {
        await supabaseAdmin
          .from('notification_email')
          .select(column)
          .limit(1);
        log(`  ‚úÖ Column '${column}' exists`, 'success');
      } catch (err) {
        log(`  ‚ùå Column '${column}' missing: ${err.message}`, 'error');
      }
    }

    return true;
  } catch (error) {
    log(`‚ùå Table structure verification failed: ${error.message}`, 'error');
    return false;
  }
}

async function verifyIndexes() {
  log('üîç Verifying indexes...');
  
  try {
    const { data: indexes, error } = await supabaseAdmin
      .rpc('get_table_indexes', { table_name: 'notification_email' })
      .catch(() => {
        // Fallback: try to query with different conditions to test indexes
        return Promise.all([
          supabaseAdmin.from('notification_email').select('*').eq('status', 'pending').limit(1),
          supabaseAdmin.from('notification_email').select('*').order('created_at', { ascending: false }).limit(1),
          supabaseAdmin.from('notification_email').select('*').eq('order_id', 'test').limit(1),
          supabaseAdmin.from('notification_email').select('*').eq('event_type', 'test').limit(1)
        ]);
      });

    if (error) {
      log(`‚ùå Index verification failed: ${error.message}`, 'error');
      return false;
    }

    log('‚úÖ Indexes appear to be working', 'success');
    return true;
  } catch (error) {
    log(`‚ùå Index verification failed: ${error.message}`, 'error');
    return false;
  }
}

async function verifyTriggers() {
  log('üîç Verifying triggers...');
  
  try {
    // Test the updated_at trigger by inserting and updating a test record
    const testData = {
      order_id: 'TEST-TRIGGER-001',
      event_type: 'TEST',
      status: 'pending'
    };

    // Insert test record
    const { data: insertData, error: insertError } = await supabaseAdmin
      .from('notification_email')
      .insert(testData)
      .select()
      .single();

    if (insertError) {
      log(`‚ùå Trigger test insert failed: ${insertError.message}`, 'error');
      return false;
    }

    log(`‚úÖ Test record inserted with ID: ${insertData.id}`, 'success');

    // Update the record to test the trigger
    const { data: updateData, error: updateError } = await supabaseAdmin
      .from('notification_email')
      .update({ status: 'sent' })
      .eq('id', insertData.id)
      .select()
      .single();

    if (updateError) {
      log(`‚ùå Trigger test update failed: ${updateError.message}`, 'error');
      return false;
    }

    // Check if updated_at was changed
    if (updateData.updated_at > insertData.updated_at) {
      log('‚úÖ updated_at trigger is working', 'success');
    } else {
      log('‚ùå updated_at trigger not working', 'error');
    }

    // Clean up test record
    await supabaseAdmin
      .from('notification_email')
      .delete()
      .eq('id', insertData.id);

    return true;
  } catch (error) {
    log(`‚ùå Trigger verification failed: ${error.message}`, 'error');
    return false;
  }
}

async function verifyRLSPolicies() {
  log('üîç Verifying RLS policies...');
  
  try {
    // Test RLS by trying to access with different roles
    const { data: policies, error } = await supabaseAdmin
      .rpc('get_rls_policies', { table_name: 'notification_email' })
      .catch(() => {
        // Fallback: try to insert/select to test RLS
        return supabaseAdmin
          .from('notification_email')
          .select('*')
          .limit(1);
      });

    if (error) {
      log(`‚ùå RLS verification failed: ${error.message}`, 'error');
      return false;
    }

    log('‚úÖ RLS policies appear to be working', 'success');
    return true;
  } catch (error) {
    log(`‚ùå RLS verification failed: ${error.message}`, 'error');
    return false;
  }
}

async function verifyCronFunctions() {
  log('üîç Verifying cron functions...');
  
  try {
    // Check if the cron function exists
    const { data: functions, error } = await supabaseAdmin
      .rpc('get_cron_functions')
      .catch(() => {
        // Fallback: try to call the function
        return supabaseAdmin
          .rpc('process_email_queue');
      });

    if (error) {
      log(`‚ùå Cron function verification failed: ${error.message}`, 'error');
      return false;
    }

    log('‚úÖ Cron functions appear to be working', 'success');
    return true;
  } catch (error) {
    log(`‚ùå Cron function verification failed: ${error.message}`, 'error');
    return false;
  }
}

async function verifyForeignKey() {
  log('üîç Verifying foreign key constraint...');
  
  try {
    // Try to insert with a non-existent order_id
    const { error } = await supabaseAdmin
      .from('notification_email')
      .insert({
        order_id: 'NON-EXISTENT-ORDER',
        event_type: 'TEST',
        status: 'pending'
      });

    if (error && error.message.includes('foreign key constraint')) {
      log('‚úÖ Foreign key constraint is working (correctly rejected invalid order_id)', 'success');
      return true;
    } else if (!error) {
      log('‚ùå Foreign key constraint not working (should have rejected invalid order_id)', 'error');
      return false;
    } else {
      log(`‚ùå Foreign key test failed: ${error.message}`, 'error');
      return false;
    }
  } catch (error) {
    log(`‚ùå Foreign key verification failed: ${error.message}`, 'error');
    return false;
  }
}

async function verifySampleData() {
  log('üîç Verifying with sample data...');
  
  try {
    // Get a real order from the database
    const { data: orders, error: orderError } = await supabaseAdmin
      .from('Order')
      .select('id, fullName, email')
      .limit(1);

    if (orderError || !orders.length) {
      log('‚ùå No orders found to test with', 'error');
      return false;
    }

    const testOrder = orders[0];
    log(`üìã Using test order: ${testOrder.id} (${testOrder.fullName})`, 'info');

    // Insert a test notification
    const { data: notification, error: insertError } = await supabaseAdmin
      .from('notification_email')
      .insert({
        order_id: testOrder.id,
        event_type: 'TEST_VERIFICATION',
        status: 'pending'
      })
      .select()
      .single();

    if (insertError) {
      log(`‚ùå Sample data insert failed: ${insertError.message}`, 'error');
      return false;
    }

    log(`‚úÖ Sample notification inserted: ${notification.id}`, 'success');

    // Clean up
    await supabaseAdmin
      .from('notification_email')
      .delete()
      .eq('id', notification.id);

    log('‚úÖ Sample data verification completed', 'success');
    return true;
  } catch (error) {
    log(`‚ùå Sample data verification failed: ${error.message}`, 'error');
    return false;
  }
}

async function runVerification() {
  log('üöÄ Starting Database Setup Verification...');
  console.log('');

  const results = {
    tableStructure: false,
    indexes: false,
    triggers: false,
    rlsPolicies: false,
    cronFunctions: false,
    foreignKey: false,
    sampleData: false
  };

  try {
    results.tableStructure = await verifyTableStructure();
    console.log('');

    results.indexes = await verifyIndexes();
    console.log('');

    results.triggers = await verifyTriggers();
    console.log('');

    results.rlsPolicies = await verifyRLSPolicies();
    console.log('');

    results.cronFunctions = await verifyCronFunctions();
    console.log('');

    results.foreignKey = await verifyForeignKey();
    console.log('');

    results.sampleData = await verifySampleData();
    console.log('');

    // Summary
    log('üìä Verification Summary:');
    log(`‚úÖ Table Structure: ${results.tableStructure ? 'PASS' : 'FAIL'}`);
    log(`‚úÖ Indexes: ${results.indexes ? 'PASS' : 'FAIL'}`);
    log(`‚úÖ Triggers: ${results.triggers ? 'PASS' : 'FAIL'}`);
    log(`‚úÖ RLS Policies: ${results.rlsPolicies ? 'PASS' : 'FAIL'}`);
    log(`‚úÖ Cron Functions: ${results.cronFunctions ? 'PASS' : 'FAIL'}`);
    log(`‚úÖ Foreign Key: ${results.foreignKey ? 'PASS' : 'FAIL'}`);
    log(`‚úÖ Sample Data: ${results.sampleData ? 'PASS' : 'FAIL'}`);

    const passed = Object.values(results).filter(Boolean).length;
    const total = Object.keys(results).length;

    console.log('');
    if (passed === total) {
      log('üéâ All verifications passed! Database setup is correct.', 'success');
    } else {
      log(`‚ö†Ô∏è ${passed}/${total} verifications passed. Some issues need attention.`, 'error');
    }

  } catch (error) {
    log(`‚ùå Verification failed: ${error.message}`, 'error');
  }
}

// Run the verification
runVerification().catch(error => {
  log(`‚ùå Fatal error: ${error.message}`, 'error');
  process.exit(1);
});
